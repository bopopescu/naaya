/*** LuxToolTip, Version 1.1* A class to create a single instance of a tooltip that can be called by any onscreen event.* Composed of MovieClip, Tween, TextField, and TextFormat. * updates at <http://www.luxagraf.com/code/code>** @author: sng* @version: 1.1.0		changed the gradient math for the shadow to utilize quasimodos shadow 							example which was much better than mine.* @version: 1.0.0		added gradient-based shadow and compensation for tips that might be *							drawn off stage* @version: 0.1.b2      added delay before revealHint() gets called. exposed method delay() *                       	to allow user to set delay time in milliseconds default is 800* @version: 0.1.b       added tween for fade out* @version: 0.1.a		initial release*//*** Usage:* add the folder com to the folder containing you .fla (or if you want to put it somewhere else, add the path to your class path listing in the publish settings)* add the follow code to your movie:* import com.luxagraf.public_classes.** myHint:LuxToolTip = new LuxToolTip(my_mc, 100, "_sans", 10, 000)* myBtn.onRollOver=function(){*   myHint.showHint("Some String")* }* myBtn.onRollOut = function() {*   myHint.hideHint()* }*/class com.luxagraf.public_classes.LuxToolTip {	//store reference to background	private var $container:MovieClip;	private var $textFormatObj:TextFormat;	private var $textField;	//createTextField() returns void so I can't type this variable	//:TextField	private var $background:MovieClip;	private var $timer:Number;	private var $time:Number = 800;	private var $hideTween:Object;	//references to constructor passed values	private var $fontSize:Number;	private var $shadow:MovieClip;	private var $w:Number;	private var $h:Number;	private var $text:String;	private var $font:String;	private var $color:Number;	private var $percentShadow:Number = 50;	private var $fillColor = undefined;	private var $borderColor:Number = 999999;	private var factor:Number;	/**	* LuxTextObj Constructor	*	* @param target                The movie clip to which the LuxToolTip will be attached	* @param depth                 The depth in target at which to attach clips	*                                the heirarchy is:	*                                   $container [user passed value depth]	*                                       2: $textField	*                                       1: $background 	*                                       0: shadow	* @param font                  The name of the font to use (will be embedded)	* @param fontSize              The size of the font	* @param color                 The color of the font	* @param linkageID             A reference to an library symbol to attach 	* @param borderColor           color of the border (if not using linkageID)	* @param fillColor             color of the fill (if not using linkageID)	*	*/	public function LuxToolTip(target:MovieClip, depth:Number, font:String, fontSize:Number, color:Number, embedFlag:Boolean, borderColor:Number, fillColor) {		//assign property values to class object		$fillColor = fillColor;		$borderColor = borderColor;		//create a new TextFormat object		$textFormatObj = new TextFormat();		//pass values the textFormat method		textFormat(font, fontSize,  color);		//create clip to hold everything store reference in class variable $container		$container = target.createEmptyMovieClip("container_mc", depth);		//call the makeTextField method		makeTextField();		$container._visible = false;	}/*###########################################################################################################  PUBLIC METHODS  ############################################################################################################*/	/**	* formats the TextFormat object public method to allow multiple formats	*	* @param font             String value for font name	* @param color            Number value for color	* @param fontSize         Number value for fontSize	*	*/	public function textFormat(font:String, fontSize:Number, color:Number):Void {		$font = font;		$color = color;		$fontSize = fontSize;		$textFormatObj.font = $font;		$textFormatObj.color = $color;		$textFormatObj.size = $fontSize;		$textField.setTextFormat($textFormatObj);	}		public function setBG(borderColor, fillColor):Void{	   $borderColor=borderColor	   $fillColor=fillColor	   drawBackGround()	}	/**	* getter and setter methods for the TextField object htmlText attribute 	* (wrapper function for TextField methods)	* setter method also resizes background to fit new text if it has changed 	* since the last time	* this method was called. if not conserve resources, do nothing (return)	*	* @param text            string value for textfield	*/	public function get text():String {		return $textField.htmlText;	}	public function set text(t:String):Number {		if ($text != t) {			$text = t;			$textField.htmlText = t;			$textField.setTextFormat($textFormatObj);			$w = width + 2;			$h = height + 2;			drawBackGround();		}		else {			return;		}	}	/**	* getter methods for the TextField object width and height properties	* (wrapper function for TextField methods)	*/	public function get width() : Number {		return $textField._width;	}	public function get height():Number {		return $textField._height;	}	/**	* allow user to define the length of delay before tip is revealed	* default is 800 milliseconds passed value is in milliseconds	*/	public function get _delay():Number {		return $time;	}	public function set _delay(time:Number):Void {		$time = time;	}	/**	* allow user to define the visibility of the shadow.	* default is 50%	*/	public function get _shadow():Number {		return $percentShadow;	}	public function set _shadow(percent:Number):Void {		$percentShadow = percent;		drawBackGround()	}	/**	* method to show tool tip	* as of version 1.0.2 this is a two stage process to allow for a setInterval based 	* delay before the tip is revealed. public function remains the same. New private 	* function is called after the specified delay	* 	* @param str            String value for ToolTip text	*/	public function showHint(str:String):Void {		$timer = setInterval(this, "drawTip", $time, str);	}		/**	* method to hide tool tip	* creates $hideTween using Tween class. Uses the tween method onMotionFinished to 	* set $container to _visible=false so it won't consume resourses	* 	*/	public function hideHint():Void {		clearInterval($timer);		$shadow._visible=false		$hideTween = new mx.transitions.Tween($container, "_alpha", mx.transitions.easing.Regular.easeOut, 100, 0, .5, true);		$hideTween.onMotionFinished = function() {			this._visible = false;			this._alpha = 100;		};	}/*##########################################################################################################  PRIVATE METHODS  ############################################################################################################*/	/**	* position method for $container (the whole thing text and background) 	* (wrapper function for MovieClip methods)	* positioning is relative to _root	*	* @param x            Number value for x dimension	* @param y            Number value for y dimension	*/	private function setpos(x:Number, y:Number):Void {		$container._x = x;		$container._y = y;	}	/**	* method called by showHint using setInterval clears the tween if one exists and 	* then positions the hint relative to the cursor	*	*/	private function drawTip(str:String) {		clearInterval($timer);		if ($hideTween != undefined) {			$hideTween.stop();			$hideTween.fforward();		}		$container._visible = true;		$container._alpha = 100;		$shadow._visible=true;		text = str;		//check to make sure hint won't be offstage if so move onstage		if ((_root._xmouse + $w) >= Stage.width && (_root._ymouse + $h+18) >= Stage.height){			setpos((_root._xmouse)-($w+5), _root._ymouse - ($h+5))		} else if ((_root._xmouse + $w) >= Stage.width){			setpos((_root._xmouse)-($w+5), _root._ymouse + 18)		} else if ((_root._ymouse + $h+18) >= Stage.height){			setpos(_root._xmouse, _root._ymouse - ($h+5))		} else {			setpos(_root._xmouse + 18, _root._ymouse + 18);		}	}	/**	* create the onscreen textField	*/	private function makeTextField():Void {		$textField = $container.createTextField("textField", 7, 0, 0, 10, 10);		$textField = $container.textField;		$textField.autoSize = "left";		$textField.multiline = true;		$textField.html = true;		$textField.embedFonts = true;		$textField.selectable = false;		$textField.setTextFormat($textFormatObj);	}	/**	*	* draw background 	*	*/	private function drawBackGround():Void {		$background = $container.createEmptyMovieClip("background", 2);		$background.moveTo(0, 0);		$background.lineStyle(0, $borderColor);		if ($fillColor==undefined){		$background.beginFill(0xF8F8CB, 100);		} else {		$background.beginFill($fillColor, 100);		}		// Draw the box.		$background.lineTo($w, 0);		$background.lineTo($w, $h);		$background.lineTo(0, $h);		$background.lineTo(0, 0);		// Formally stop filling the shape.		$background.endFill();		//position to allow padding around textField		$background._x = -2;		$background._y = -2;		blurredRect(0, 0, $w+3, $h+3, 10, 0x000000, _shadow)	}//#####################Math taken from Mario Klingmann's shadow prototype###################//#####################            V1.0 by Mario Klingemann              ###################//#####################                www.quasimondo.com                ###################	private function blurredRect(x, y, width, height, blur, color, alpha):Void {	$shadow = $container.createEmptyMovieClip("shadow", 1);	$shadow.lineStyle();	var f = [];	var sum = 0;	for (var i = 1; i<blur+1; i++) {		f[i-1] = i*i;		sum += f[i-1];	}	var newfactor= 2;	var counter = 40;	do {		factor=newfactor		var b = 0;		for (var i = 0; i<=blur; i++) {			var ftemp = (f[i]*(factor*alpha)/sum)/100;			b = b*(1-ftemp)+ftemp;		}		counter--;		newfactor *= alpha/(100*b);	} while ((counter>0) && (Math.abs(100*b-alpha)>.5));	for (var i = 0; i<=blur; i++) {		f[i] *= (factor*alpha)/sum;	}	for (var i = 0; i<=blur; i++) {		$shadow.beginFill(color, f[i]);		roundRect(1+(x+i)-blur/2, 1+(y+i)-blur/2, x+width-i+blur/2-1, y+height-i+blur/2-1, blur-(i*2/3));		$shadow.endFill();	}};	private function roundRect(x1, y1, x2, y2, r):Void {	r = Math.min(Math.abs(r), Math.min(Math.abs(x1-x2), Math.abs(y1-y2))/2);	var f = 0.707106781186548*r;	var a = 0.588186525863094*r;	var b = 0.00579432557070009*r;	var ux = Math.min(x1, x2);	var uy = Math.min(y1, y2);	var lx = Math.max(x1, x2);	var ly = Math.max(y1, y2);	$shadow.moveTo(ux+r, uy);	var cx = lx-r;	var cy = uy+r;	$shadow.lineTo(cx, uy);	$shadow.curveTo(lx-a, uy+b, cx+f, cy-f);	$shadow.curveTo(lx-b, uy+a, lx, uy+r);	cy = ly-r;	$shadow.lineTo(lx, cy);	$shadow.curveTo(lx-b, ly-a, cx+f, cy+f);	$shadow.curveTo(lx-a, ly-b, lx-r, ly);	cx = ux+r;	$shadow.lineTo(cx, ly);	$shadow.curveTo(ux+a, ly-b, cx-f, cy+f);	$shadow.curveTo(ux-b, ly-a, ux, ly-r);	cy = uy+r;	$shadow.lineTo(ux, cy);	$shadow.curveTo(ux+b, uy+a, cx-f, cy-f);	$shadow.curveTo(ux+a, uy+b, ux+r, uy);};}